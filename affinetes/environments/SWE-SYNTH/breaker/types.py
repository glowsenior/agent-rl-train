"""
Breaker Module Type Definitions

Data classes for input/output of the breaker module.
"""

from dataclasses import dataclass, field
from typing import List, Dict, Optional, Any
import time


@dataclass
class BreakerInput:
    """
    Input for the Breaker module.

    Contains all information needed to inject a bug and verify it.
    """
    # Docker environment configuration
    docker_image: str
    base_commit: str
    repo: str
    instance_id: str

    # Code state - gold_patch is the correct fix already applied
    gold_patch: str

    # Test configuration
    test_cases: List[str]              # All test case names
    test_runner_script: str            # Script to run tests
    test_parser_script: str            # Script to parse test output
    test_files: str                    # Comma-separated test files

    # Bug generation configuration
    bug_types: List[str]               # Bug types to inject
    seed: int                          # Random seed for reproducibility

    # Model configuration
    model: str                         # Model name for agents
    api_base: str                      # API base URL
    api_key: str                       # API key

    # Optional context
    test_patch: Optional[str] = None   # Test code diff for context
    problem_statement_original: Optional[str] = None  # Original problem
    env_cmds: str = ""                 # Environment setup commands
    before_repo_set_cmd: str = ""      # Command before repo setup

    # Agent configuration
    temperature: float = 0.7
    max_iterations: int = 30
    cost_limit: float = 5.0
    timeout: int = 300


@dataclass
class AgentResult:
    """Result from a code agent execution"""
    diff: str                          # Code changes as diff
    output_text: str                   # Agent's final output text
    steps: int                         # Number of steps taken
    cost: float                        # Execution cost
    exit_status: str = ""              # Exit status
    error: Optional[str] = None        # Error message if failed


@dataclass
class InjectionResult:
    """Result from Bug Injector"""
    bug_patch: str                     # The injected bug as a diff
    bug_description: str               # Technical description of the bug
    failed_tests: List[str]            # Tests that failed due to the bug
    passed_tests: List[str]            # Tests that still pass
    error_output: str                  # Test error output for context
    agent_steps: int                   # Number of agent steps taken
    agent_cost: float                  # Cost of agent execution


@dataclass
class BreakerOutput:
    """
    Final output from the Breaker module.

    This can be cached and used later by external verifiers.
    """
    # Source information
    source: Dict[str, Any] = field(default_factory=dict)

    # Bug information
    bug_patch: str = ""
    bug_types: List[str] = field(default_factory=list)
    bug_description: str = ""
    problem_statement: str = ""        # Generated by Summarizer
    target_tests: List[str] = field(default_factory=list)  # Failed tests

    # Generation metadata
    generation: Dict[str, Any] = field(default_factory=dict)

    # Original context (for verification)
    original: Dict[str, Any] = field(default_factory=dict)

    # Verification status
    verified: bool = False

    def to_dict(self) -> Dict[str, Any]:
        """Convert to dictionary for caching"""
        return {
            "source": self.source,
            "bug": {
                "patch": self.bug_patch,
                "bug_types": self.bug_types,
                "description": self.bug_description,
                "problem_statement": self.problem_statement,
                "target_tests": self.target_tests,
            },
            "generation": self.generation,
            "original": self.original,
            "verification": {"verified": self.verified},
        }

    @classmethod
    def from_dict(cls, data: Dict[str, Any]) -> "BreakerOutput":
        """Create from dictionary (e.g., from cache)"""
        bug = data.get("bug", {})
        return cls(
            source=data.get("source", {}),
            bug_patch=bug.get("patch", ""),
            bug_types=bug.get("bug_types", []),
            bug_description=bug.get("description", ""),
            problem_statement=bug.get("problem_statement", ""),
            target_tests=bug.get("target_tests", []),
            generation=data.get("generation", {}),
            original=data.get("original", {}),
            verified=data.get("verification", {}).get("verified", False),
        )

    @classmethod
    def create(
        cls,
        input: "BreakerInput",
        injection: "InjectionResult",
        problem_statement: str,
    ) -> "BreakerOutput":
        """Create BreakerOutput from injection result"""
        return cls(
            source={
                "dataset": "SWE-bench_Pro",
                "swe_instance_id": input.instance_id,
                "base_commit": input.base_commit,
                "repo": input.repo,
            },
            bug_patch=injection.bug_patch,
            bug_types=input.bug_types,
            bug_description=injection.bug_description,
            problem_statement=problem_statement,
            target_tests=injection.failed_tests,
            generation={
                "breaker_model": input.model,
                "seed": input.seed,
                "temperature": input.temperature,
                "mode": "agent",
                "agent_steps": injection.agent_steps,
                "agent_cost": injection.agent_cost,
                "created_at": time.strftime("%Y-%m-%dT%H:%M:%SZ"),
            },
            original={
                "gold_patch": input.gold_patch,
                "problem_statement": input.problem_statement_original or "",
                "all_tests": input.test_cases,
            },
            verified=True,
        )


class BreakerException(Exception):
    """Exception raised by breaker module"""
    pass
